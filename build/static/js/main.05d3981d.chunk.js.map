{"version":3,"sources":["MapContainer.js","App.js","serviceWorker.js","index.js"],"names":["MapContainer","state","locations","name","location","lat","lng","query","markers","infowindow","_this","props","google","maps","InfoWindow","highlightedIcon","onclickLocation","that","Object","assertThisInitialized","document","querySelector","addEventListener","e","target","nodeName","markerInd","findIndex","m","title","toLowerCase","innerText","populateInfoWindow","displayInfowindow","handleValueChange","setState","value","addMarkers","bounds","LatLngBounds","forEach","ind","marker","Marker","position","map","addListener","toConsumableArray","concat","extend","fitBounds","defaultIcon","getIcon","_this$state","setIcon","setContent","open","makeMarkerIcon","markerColor","MarkerImage","Size","Point","this","loadMap","mapRef","refs","node","ReactDOM","findDOMNode","mapConfig","assign","center","zoom","mapTypeId","Map","_this$state2","l","i","includes","setVisible","close","length","react_default","a","createElement","className","role","type","onChange","filter","getVisible","key","ref","Component","App","tabIndex","MapContainer_MapContainer","GoogleApiWrapper","apiKey","isLocalhost","Boolean","window","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","render","src_App","getElementById","URL","process","origin","fetch","response","status","headers","get","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.05d3981d.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport ReactDOM from 'react-dom';\n\n\nexport default class MapContainer extends Component {\n\n  state = {\n    locations: [\n      {name: \"Cinemaxx Glória\", location: {lat: -21.20983949, lng: -41.88704682}},\n      {name: \"Cristo Redentor\", location: {lat: -21.20097577, lng: -41.88172988}},\n      {name: \"Hospital São José do Avaí\", location: {lat: -21.20188602, lng: -41.88968531}},\n      {name: \"Prefeitura Municipal\", location: {lat: -21.19874516, lng: -41.904684232}},\n      {name: \"Centro Poliesportivo\", location: {lat: -21.19495355, lng: -41.90685375}}\n    ],\n    query: '',\n    markers: [],\n    infowindow: new this.props.google.maps.InfoWindow(),\n    highlightedIcon: null\n  }\n\n  componentDidMount() {\n    this.loadMap()\n    this.onclickLocation()\n    // Create a \"highlighted location\" marker color for when the user\n    // clicks on the marker.\n    this.setState({highlightedIcon: this.makeMarkerIcon('FFFF24')})\n  }\n\n  loadMap() {\n    if (this.props && this.props.google) {\n      const {google} = this.props\n      const maps = google.maps\n\n      const mapRef = this.refs.map\n      const node = ReactDOM.findDOMNode(mapRef)\n\n      const mapConfig = Object.assign({}, {\n        center: {lat: -21.1877747, lng: -41.8799408},\n        zoom: 12,\n        mapTypeId: 'roadmap'\n      })\n\n      this.map = new maps.Map(node, mapConfig)\n      this.addMarkers()\n    }\n\n  }\n\n  onclickLocation = () => {\n    const that = this\n    const {infowindow} = this.state\n\n    const displayInfowindow = (e) => {\n      const {markers} = this.state\n      const markerInd =\n        markers.findIndex(m => m.title.toLowerCase() === e.target.innerText.toLowerCase())\n      that.populateInfoWindow(markers[markerInd], infowindow)\n    }\n    document.querySelector('.locations-list').addEventListener('click', function (e) {\n      if (e.target && e.target.nodeName === \"LI\") {\n        displayInfowindow(e)\n      }\n    })\n  }\n\n  handleValueChange = (e) => {\n    this.setState({query: e.target.value})\n  }\n\n  addMarkers = () => {\n    const {google} = this.props\n    let {infowindow} = this.state\n    const bounds = new google.maps.LatLngBounds()\n\n    this.state.locations.forEach((location, ind) => {\n      const marker = new google.maps.Marker({\n        position: {lat: location.location.lat, lng: location.location.lng},\n        map: this.map,\n        title: location.name\n      })\n\n      marker.addListener('click', () => {\n        this.populateInfoWindow(marker, infowindow)\n      })\n      this.setState((state) => ({\n        markers: [...state.markers, marker]\n      }))\n      bounds.extend(marker.position)\n    })\n    this.map.fitBounds(bounds)\n  }\n\n  populateInfoWindow = (marker, infowindow) => {\n    const defaultIcon = marker.getIcon()\n    const {highlightedIcon, markers} = this.state\n    // Check to make sure the infowindow is not already opened on this marker.\n    if (infowindow.marker !== marker) {\n      // reset the color of previous marker\n      if (infowindow.marker) {\n        const ind = markers.findIndex(m => m.title === infowindow.marker.title)\n        markers[ind].setIcon(defaultIcon)\n      }\n      // change marker icon color of clicked marker\n      marker.setIcon(highlightedIcon)\n      infowindow.marker = marker\n      infowindow.setContent(`<h3>${marker.title}</h3><h4>user likes it</h4>`)\n      infowindow.open(this.map, marker)\n      // Make sure the marker property is cleared if the infowindow is closed.\n      infowindow.addListener('closeclick', function () {\n        infowindow.marker = null\n      })\n    }\n  }\n\n  makeMarkerIcon = (markerColor) => {\n    const {google} = this.props\n    let markerImage = new google.maps.MarkerImage(\n      'http://chart.googleapis.com/chart?chst=d_map_spin&chld=1.15|0|' + markerColor +\n      '|40|_|%E2%80%A2',\n      new google.maps.Size(21, 34),\n      new google.maps.Point(0, 0),\n      new google.maps.Point(10, 34),\n      new google.maps.Size(21, 34));\n    return markerImage;\n  }\n\n  render() {\n    const {locations, query, markers, infowindow} = this.state\n    if (query) {\n      locations.forEach((l, i) => {\n        if (l.name.toLowerCase().includes(query.toLowerCase())) {\n          markers[i].setVisible(true)\n        } else {\n          if (infowindow.marker === markers[i]) {\n            // close the info window if marker removed\n            infowindow.close()\n          }\n          markers[i].setVisible(false)\n        }\n      })\n    } else {\n      locations.forEach((l, i) => {\n        if (markers.length && markers[i]) {\n          markers[i].setVisible(true)\n        }\n      })\n    }\n    return (\n      <div>\n        <div className=\"container\">\n          <div className=\"text-input\">\n            <input role=\"search\" type='text'\n                   value={this.state.value}\n                   onChange={this.handleValueChange}/>\n            <ul className=\"locations-list\">{\n              markers.filter(m => m.getVisible()).map((m, i) =>\n                (<li key={i}>{m.title}</li>))\n            }</ul>\n          </div>\n          <div role=\"application\" className=\"map\" ref=\"map\">\n            loading map...\n          </div>\n        </div>\n      </div>\n    )\n  }\n}","import React, { Component } from 'react';\nimport { GoogleApiWrapper } from 'google-maps-react';\nimport MapContainer from './MapContainer';\nimport './main.css';\n\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <div className={\"menu\"} tabIndex={\"0\"}>         \n        </div>\n      \n        <h1 className=\"heading\"> Neighbordhood Map React </h1>\n        <MapContainer google={this.props.google} />\n      </div>\n    );\n  }\n}\n\nexport default GoogleApiWrapper({\n  apiKey: 'AIzaSyBqeCAur3WuwLz9vaZyfuVA4WzfqSFjmiM'\n})(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nserviceWorker.register();\n"],"sourceRoot":""}